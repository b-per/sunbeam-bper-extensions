#!/usr/bin/env python

import json
import sys
from pathlib import Path
from datetime import datetime
import argparse
import yaml

parser = argparse.ArgumentParser()

parser.add_argument("--command", type=str, help="The command to be executed")
parser.add_argument("--filter", type=str, help="The filter for the command")
parser.add_argument(
    "--include-packages", action="store_true", help="Include packages in the results"
)

args = parser.parse_args()

run_results_file_path = Path("target/run_results.json")
run_results = json.loads(run_results_file_path.read_text())

manifest_file_path = Path("target/manifest.json")
manifest = json.loads(manifest_file_path.read_text())

dbt_project_file = Path("dbt_project.yml")
dbt_project_name = yaml.safe_load(dbt_project_file.read_text())["name"]


def show_status(result: dict) -> str:
    status = result["status"]
    if status in ["success", "pass"]:
        return f"{status} ✅"
    if status in ["warn"]:
        return f"{status} 🚧"
    if status in ["skipped"]:
        return f"{status} 🦘"
    else:
        return f"{status} ❌"


def execute_time_int(result: dict) -> int:
    if len(result["timing"]) < 2:
        return 999_999
    end_time = datetime.fromisoformat(result["timing"][1]["completed_at"].rstrip("Z"))
    start_time = datetime.fromisoformat(result["timing"][1]["started_at"].rstrip("Z"))
    return int((end_time - start_time).total_seconds())


def execute_time_seconds(result: dict) -> str:
    execute_time = execute_time_int(result)
    if execute_time == 999_999:
        return ""
    else:
        return "{:,}".format(execute_time) + " secs"


def number_rows(result: dict) -> str:
    if "rows_affected" not in result["adapter_response"]:
        return "-"

    rows_adapter = result["adapter_response"]["rows_affected"]
    if rows_adapter in [0, 1]:
        return "N/A"

    return "{:,}".format(result["adapter_response"].get("rows_affected", "-")) + " rows"

def show_uniqueid(result: dict) -> str:
    unique_id = result["unique_id"]
    unique_id_model, unique_id_package, unique_id_node, *extra = unique_id.split(".") 
    return f"{unique_id_model[0].upper()}: {unique_id_node}"


# this is how we display different pages
# this is the main page
if not args.command or args.command == "run-results":
    list_rows = []
    for result in sorted(run_results["results"], key=execute_time_int, reverse=True):
        if result["unique_id"].split(".")[1] != dbt_project_name and not args.include_packages:
            continue

        row = {}
        actions = []
        row["title"] = show_uniqueid(result)
        row["subtitle"] = show_status(result)
        row["accessories"] = [execute_time_seconds(result), number_rows(result)]

        actions.append(
            {
                "type": "copy",
                "title": "Copy Name",
                "key": "y",
                "text": result["unique_id"].split(".")[-1],
            }
        )

        if Path(manifest["nodes"][result["unique_id"]]["original_file_path"]).exists():
            actions.append(
                {
                    "type": "open",
                    "title": "Open file",
                    "target": manifest["nodes"][result["unique_id"]]["original_file_path"],
                    "key": "o",
                }
            )

        compiled_path = manifest["nodes"][result["unique_id"]].get("compiled_path")
        if compiled_path and Path(compiled_path).exists():
            actions.append(
                {
                    "type": "open",
                    "title": "Open compiled code",
                    "target": manifest["nodes"][result["unique_id"]]["compiled_path"],
                    "key": "c",
                }
            )

        patch_path = manifest["nodes"][result["unique_id"]]["patch_path"]
        if patch_path:
            yml_file = patch_path.split("://")[-1]
            if yml_file and Path(yml_file).exists():
                actions.append(
                    {
                        "type": "open",
                        "title": "Open YAML",
                        "target": yml_file,
                        "key": "c",
                    }
                )

        actions.append(
            {
                "type": "push",
                "title": "See details",
                "key": "d",
                "command": [__file__, "--command", "node-details", "--filter", result["unique_id"]],
            }
        )

        row["actions"] = actions
        list_rows.append(row)

    json.dump(
        {
            "type": "list",
            "items": list_rows,
        },
        sys.stdout,
    )

# this is the page when we look at details
if args.command == "node-details":
    node_id = args.filter
    node = manifest["nodes"][node_id]
    node_config = node["config"]

    newline = "\n"

    if node["resource_type"] in ["model", "snapshot", "seed"]:
        list_depends_on = []
        for depends_on_node in node.get("depends_on", {}).get("nodes", []):
            # only show the nodes for now
            if depends_on_node in manifest["nodes"]:
                list_depends_on.append(
                    f"""  - {depends_on_node} -- {manifest["nodes"][depends_on_node]["config"].get("materialized")}"""
                )

        tests_for_model = [
            test
            for test, test_values in manifest["nodes"].items()
            if test_values["resource_type"] == "test"
            and node_id in test_values["depends_on"]["nodes"]
        ]
        tests_to_print = ["  - " + test for test in tests_for_model]

        details = f"""
Model: {node_id}

Config:
  - Materialization: {node_config["materialized"]}
  - Has YAML: {"Yes" if node["patch_path"] else "No"}
  - Group: {node_config.get("group","N/A")}
  - Schema: {node_config["schema"]}
  - Alias: {node_config["alias"]}
  - Pre-hook: {"Yes" if node_config["pre-hook"] else "No"}
  - Post-hook: {"Yes" if node_config["post-hook"] else "No"}
  - Meta: {node_config["meta"]}
  - Contract: {node_config.get("contract","N/A")}
  - Constraints: {node_config.get("constraints","N/A")}

Depends on models: 
{newline.join(list_depends_on)}

Tests: 
{newline.join(tests_to_print) if tests_to_print else "  - None"}
"""

        ret = {"title": "Model details", "type": "detail", "text": details}

    elif node["resource_type"] == "test":
        details = f"""
Test: {node_id}

Config:
    Severity: {node_config["severity"]}
    Schema: {node_config["schema"]}
"""

        ret = {"title": "Test details", "type": "detail", "text": details}

    json.dump(
        ret,
        sys.stdout,
    )
